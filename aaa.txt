Zadanie 1: Implementacja Klasy Przechowującej Stan Gry (GameState)
Kontekst: W obecnej wersji gry stan obiektów (pozycja piłki, pozycja paletki, układ bloków) jest "rozsiany" po różnych obiektach w pamięci. Aby móc zapisać grę lub stworzyć system "Cofnij" (Undo), musimy mieć możliwość zrobienia "zdjęcia" (snapshot) aktualnej sytuacji na planszy.

Cel: Zaprojektować klasę (lub strukturę) GameState, która będzie kontenerem na same dane ("surowe liczby"), pozbawionym logiki biznesowej (rysowania, kolizji).

Polecenia do wykonania:

Stwórz prostą strukturę pomocniczą BlockData:

Ma przechowywać tylko to, co niezbędne do odtworzenia bloku: pozycję (X, Y) oraz punkty życia (HP).

struct BlockData {
    float x, y;
    int hp;
};
Zaimplementuj klasę GameState:

Pola prywatne:

sf::Vector2f paddlePosition; – pozycja paletki.

sf::Vector2f ballPosition; – pozycja piłki.

sf::Vector2f ballVelocity; – wektor prędkości piłki (niezbędny, by po wczytaniu piłka leciała w tę samą stronę).

std::vector<BlockData> blocks; – lista stanów wszystkich klocków.

Metoda capture(...) (lub konstruktor):

Metoda ta powinna przyjmować referencje do bieżących obiektów gry: const Paletka&, const Pilka&, const std::vector<Stone>&.

Zadaniem metody jest "wyciągnięcie" danych z tych obiektów i przepisanie ich do pól GameState.

Wskazówka: Aby to zadziałało, w klasie Stone może być potrzebny nowy getter: int getHP() const;.

Wynik: Po wykonaniu zadania powinieneś móc w dowolnym momencie gry (np. po naciśnięciu 'P' - pauza) stworzyć obiekt GameState, który w pamięci będzie trzymał komplet informacji o obecnej klatce gry.

Zadanie 2: Zapis stanu do pliku (Zapis)
Kontekst: Mając klasę GameState (z Zadania 1), posiadamy już wszystkie dane w jednym miejscu. Teraz należy je utrwalić na dysku twardym, aby gracz mógł zamknąć program i wrócić do rozgrywki później.

Cel: Napisanie funkcji zapisującej zawartość obiektu GameState do pliku tekstowego (savegame.txt).

Polecenia do wykonania:

W klasie GameState dodaj metodę bool saveToFile(const std::string& filename);.

Implementacja zapisu (użyj <fstream>):

Otwórz plik do zapisu (std::ofstream).

Zapisz dane w ustalonym, czytelnym formacie tekstowym.

Proponowany format pliku:

Linia 1: PADDLE [x] [y]

Linia 2: BALL [x] [y] [vx] [vy]

Linia 3: BLOCKS_COUNT [liczba_blokow]

Kolejne linie (po jednej dla bloku): [x] [y] [hp]

Integracja z main.cpp (lub klasą Game):

W pętli obsługi zdarzeń dodaj obsługę klawisza (np. F5).

Po naciśnięciu klawisza:

Utwórz obiekt GameState.

Wywołaj capture(), przekazując obecną paletkę, piłkę i wektor bloków.

Wywołaj saveToFile("zapis.txt").

Wyświetl w konsoli komunikat "Gra zapisana!".

Przykład fragmentu kodu zapisu (podpowiedź):


 
#include <fstream>

// Wewnątrz GameState::saveToFile...
std::ofstream file(filename);
if (!file.is_open()) return false;

// Zapis Paletki
file << paddlePosition.x << " " << paddlePosition.y << "\n";

// Zapis Piłki
file << ballPosition.x << " " << ballPosition.y << " " 
     << ballVelocity.x << " " << ballVelocity.y << "\n";

// Zapis liczby bloków
file << blocks.size() << "\n";

// Zapis bloków
for (const auto& block : blocks) {
    file << block.x << " " << block.y << " " << block.hp << "\n";
}

file.close();
return true;

Zadanie 3: Odczyt Stanu Gry i Integracja z Menu
Kontekst: Mamy już mechanizm zapisu danych do pliku (saveToFile z Zadania 2). Aby system był użyteczny, gracz musi mieć możliwość wczytania tych danych i wznowienia rozgrywki. Naturalnym miejscem na taką opcję jest Menu Główne.

Cel: Zaimplementować funkcję odczytu danych z pliku tekstowego, odtworzenia stanu obiektów (Deserializacja) oraz dodać opcję "Wczytaj grę" do klasy Menu.

Polecenia do wykonania:

Rozszerzenie klasy GameState (Deserializacja):

Dodaj metodę bool loadFromFile(const std::string& filename);.

Metoda musi otwierać plik do odczytu (std::ifstream) i parsować dane zgodnie z formatem ustalonym w Zadaniu 2.

Ważne: Podczas wczytywania bloków, musisz wyczyścić stary wektor bloków i utworzyć nowe obiekty Stone na podstawie wczytanych współrzędnych i HP.

Dodaj metodę apply(...) (lub rozszerz loadFromFile), która przepisze wczytane dane (pozycja piłki, paletki, wektor bloków) do rzeczywistych obiektów gry.

Uwaga: Może być konieczne dopisanie metody setPosition w klasie Paletka, jeśli jej nie posiada.

Aktualizacja klasy Menu:

Zwiększ MAX_LICZBA_POZIOMOW (np. do 4).

Dodaj nowy element sf::Text o treści "Wczytaj grę" (np. na drugiej pozycji, przesuwając "Wyniki" i "Wyjście" niżej).

Upewnij się, że nawigacja (strzałki góra/dół) obsługuje nowy element.

Integracja w main.cpp:

W obsłudze zdarzeń Menu (po wciśnięciu Enter na nowej opcji):

Utwórz obiekt GameState.

Wywołaj loadFromFile("zapis.txt").

Sprawdź, czy wczytywanie się powiodło (plik istnieje).

Jeśli tak: wywołaj apply(...) na obiektach paletka, pilka, bloki i zmień stan gry na Playing.

Jeśli nie: wypisz błąd w konsoli (lub nie rób nic).

Przykład fragmentu kodu odczytu (podpowiedź):

#include <fstream>
#include <string>

// Wewnątrz GameState...

bool loadFromFile(const std::string& filename) {
    std::ifstream file(filename);
    if (!file.is_open()) return false;

    std::string label; // Zmienna na napisy pomocnicze (np. "PADDLE")
    
    // 1. Wczytaj Paletkę
    if (file >> label >> paddlePosition.x >> paddlePosition.y) {
        // Dane wczytane do zmiennych tymczasowych w GameState
    }

    // 2. Wczytaj Piłkę
    if (file >> label >> ballPosition.x >> ballPosition.y >> ballVelocity.x >> ballVelocity.y) {
        // ...
    }

    // 3. Wczytaj Bloki
    int blocksCount;
    file >> label >> blocksCount;
    
    blocks.clear(); // Czyścimy stare dane
    for (int i = 0; i < blocksCount; ++i) {
        float x, y;
        int hp;
        file >> x >> y >> hp;
        blocks.push_back({x, y, hp});
    }

    file.close();
    return true;
}

// Metoda aplikująca stan do gry
void apply(Paletka& p, Pilka& b, std::vector<Stone>& stones) {
    // Zakładamy, że dodaleś setPosition do Paletki
    p.setPosition(paddlePosition); 
    
    // Pilka ma już metodę reset/setPosition
    b.reset(ballPosition, ballVelocity);

    // Odtwarzanie bloków
    stones.clear();
    // Musisz znać wymiary bloku (można je też zapisać w pliku lub wziąć ze stałych)
    sf::Vector2f size(..., ...); 
    for (const auto& data : blocks) {
        stones.emplace_back(sf::Vector2f(data.x, data.y), size, data.hp);
    }
}